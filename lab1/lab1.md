лабораторная №1.
флаг ``-с``. Эта опция означает, что необходима только компиляция. 
Из исходных файлов программы создаются объектные файлы в виде name.o
``gcc -c main.c``
Исходные файлы ваших программ компилируются в объектные файлы, а затем компоновщик связывает эти 
объектные файлы вместе, создавая исполняемый файл
![logo](https://i.ibb.co/n3s65MV/2020-03-25-18-35-59.png)

nm: получаем названия всех функций, которые определены в .o или .a
![logo](https://i.ibb.co/Wf10z4v/2020-03-25-20-15-20.png)

подключение библиотек:
Расширение .a (archive) - для статической библиотеки, .so (shared object) - для разделяемой (динамической). 
Создадим статическую библиотеку 
Скопилируем main1.c и main.c
``gcc -c main.c main1.c``
Получим 2 объектных файла :
![logo](https://i.ibb.co/R0tkQZd/2020-04-09-15-28-30.png)

Для того, чтобы создать библиотеку из объектых файлов надо вызвать программу ar со следующими параметрами: 
``ar rc libfs.a main.o main1.o ``

В результате получим файл libfs.a, в котором будут лежать копии объектых файлов f1.o и f2.o

![logo](https://i.ibb.co/jJP0RwZ/2020-04-09-15-30-18.png)

Пока у нас есть лишь архивный файл libfs.a. Чтобы из него сделать полноценную библиотеку объектных файлов надо добавить 
к этому архиву индекс символов, т.е. список вложенных в библиотеку функций и переменных, чтобы линковка происходила 
быстрее. Далается это командой: 
``ranlib libfs.a``
Программа ranlib добавит индекс к архиву и получится полноценная статическая библиотека объектных файлов.

Для компиляции нашего основного файла main.c надо сообщить компилятору, что надо использовать библиотеки.
Каталог с библиотеками указывается ключом -L, но библиотека находится в текущем каталоге, значит путь до нее 
будет в виде точки (-L.)

Используемые библиотеки перечисляются через ключ -l,
после которого указывается название библиотеки без префикса lib и окончания .a

``gcc -c main.c -L. -lfs -o rezult``

Получим файл result:

![logo](https://i.ibb.co/7Yn46qC/2020-04-09-15-34-35.png)

Запустим библиотеку:

![logo](https://i.ibb.co/THyTfmG/2020-04-09-15-36-26.png)

Мы получили статическую библиотеку.

Объектный файл создаваемый предыдущим способом вовсе не подходит для динамических библиотек. 
Связано это с тем, что все объектные файлы создаваемые обычным образом не имеют представления о том, в какие адреса 
памяти будет загружена использующая их программа. Несколько различных программ могут использовать одну библиотеку, и 
каждая из них располагается в различном адресном пространстве. Поэтому требуется, чтобы переходы в функциях библиотеки 
(операции goto на ассемблере) использовали не абсолютную адресацию, а относительную. То есть генерируемый компилятором 
код должен быть независимым от адресов, такая технология получила название PIC - Position Independent Code. В компиляторе 
gcc данная возможность включается ключом -fPIC. 

Скомпилируем наши исходные программы с этим флагом:
``gcc -fPIC -c main.c main1.c``
![logo](https://i.ibb.co/MR9LQxF/2020-04-09-15-41-30.png)

Получили два объектных файла.
Динамическая библиотека это уже не архивный файл, а настоящая загружаемая программа, поэтому созданием динамических 
библиотек занимается сам компилятор gcc. Для того, чтобы создать динамическую библиотеку надо использовать ключ -shared: 

``gcc -shared -o libfsdyn.so main.o main1.o`` 

В результате получим динамическую библиотеку libfsdyn.so.  
![logo](https://i.ibb.co/N6q2nJQ/2020-04-09-15-43-25.png)

Теперь, чтобы компилировать результирующий файл с использованием динамической библиотеки нам надо собрать файл командой: 


``gcc main.o -L. -lfsdyn -o rezultdyn``

![logo](https://i.ibb.co/rFCwP26/2020-04-09-15-49-02.png)

Но теперь, если мы попытаемся ее запустить, то мы получим ошибку:
![logo](https://i.ibb.co/VQ9jYCw/2020-04-09-15-58-00.png)

Это сообщение выдает загрузчик динамических библиотек(динамический линковщик - dynamic linker), который в нашем случае 
не может обнаружить библиотеку libfsdyn.so. Для настройки динамического линковщика существует ряд программ.   

Первая программа называется ldd. Она выдает на экран список динамических библиотек используемых в программе и их 
местоположение. В качестве параметра ей сообщается название обследуемой программы.

``ldd rezultdyn``

![logo](https://i.ibb.co/M240WJs/2020-04-09-15-59-00.png)

Программа использует три библиотеки:

    libc.so.6 - стандартную библиотеку функций языка C++.
    ld-linux.so.2 - библиотеку динамической линковки программ ELF формата.
    libfsdyn.so - нашу динамическую библиотеку функций. 

Нашу библиотеку она найти не может. Динамический линковщик ищет библиотеки только в известных ему 
каталогах, а каталог нашей программы ему не известен. 

Для того, чтобы добавить нашу директорию с библиотекой в список известных директорий надо подредактировать 
файл /etc/ld.so.conf
Получается, что наша библиотека станет "заметной", если поместить ее в один их этих каталогов, либо отдельно описать в 
отдельном каталоге. Давайте для теста опишем, добавим строку в конец файла ld.so.conf: 

![logo](https://i.ibb.co/WcfT1b8/2020-04-09-16-07-00.png)

![logo](https://i.ibb.co/rwG3RJ6/2020-04-09-16-26-52.png)

Теперь после этого динамический линковщик будет знать где можно найти наш файл, но после изменения конфигурационного 
файла ld.so.conf необходимо, чтобы система перечитала настройки заново. Это делает программа ldconfig. Пробуем запустить нашу программу: 

![logo](https://i.ibb.co/JBsVhnM/2020-04-09-16-27-49.png)

5) пример отладки ошибочной программы
сломанная программа, в сообщениях видим в чем ошибка
![logo](https://i.ibb.co/gyXRqxd/2020-03-25-20-55-23.png)

читаем, исправляем
![logo](https://i.ibb.co/pyWQn0X/2020-03-25-21-02-29.png)

6) пример автоматизации:
![logo](https://i.ibb.co/85v2WN6/2020-03-25-21-53-09.png)

Что здесь происходит?

    В 1 строке просто указана минимальная версия CMake необходимая для успешной интерпретации файла.
    В 5 строке определяется переменная PROJECT и ей задается значение hello_world — так будет называться наша программа.
    О чем и говорится в 7 строке. Конструкция ${ИМЯ_ПЕРЕМЕННОЙ} возвращает значение переменной, таким образом проект будет называться hello_world.
    В 9 строке вводятся переменные содержащие список файлов необходимых для сборки проекта.
    И в последней строке идет команда собрать исполняемый файл с именем указанном в переменной PROJECT и из файла в переменной SOURCES.

связывание двух программ:

![logo](https://i.ibb.co/Xx6MyfD/2020-03-25-21-09-54.png)

имеем два подмодуля, которые связаны между собой главным cmake и имеют свои собственные.
add_subdirectory - говорит cmake о подмодуле
add_executable - добавляет исполняемую задачу.