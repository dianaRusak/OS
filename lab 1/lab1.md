лабораторная №1.
1) установка Linux - done
2) редактор кода - CLion done
3) grep.
grep - файловый поисковик для Linux.
чтобы найти слово "python" и при этом не потерять все строки с "Python" нужно ввести команду:
``grep -i python`` 
Флаг ``-i`` позволяет игнорировать регистр. 
Если я хочу посмотреть, сколько раз в конкретном файле встречается какое-то слово, то я пользуюсь командой ``cat``,
которая читает данные из файла, передаю ей путь к файлу, пусть ```/etc/passwd```, затем вызываю grep с флагом ``-c``, которая и
занимается подсчетом. В целом команда выглядит так:
``cat /etc/pwd|grep -c abs``
Содержание файла pwd: abs1 jgjg abs
Вывод после выполнения в терминале: 2
Если я хочу наоборот посмотреть все слова, которые не равны передаваемому в grep, то я использую флаг ``-v``:
 ``cat /etc/pwd|grep -v abs`` 
Вывод после выполнения в терминале: jgjg
Если мне нужно точное совпадение, то есть хочу найти только слово abs без его вхождения в другие слова, т.е.
проигнорировать abs1, то я пользуюсь флагом ``-w``:
``cat /etc/pwd|grep -w abs``
результат: abs
4) компиляция - «перевод» программы с языка высокого уровня на машинный код.
отладка - этап разработки, состоящий из выявления и устранения ошибок.
флаг ``-с``. Эта опция означает, что необходима только компиляция. Из исходных файлов программы создаются объектные файлы в виде name.o
``gcc -c main.c``

![logo](https://i.ibb.co/n3s65MV/2020-03-25-18-35-59.png)

-о file:  Использовать file в качестве имени для создаваемого файла. 

![logo](https://i.ibb.co/CVFBT1X/2020-03-25-18-42-20.png)

-S: Вывод производится в форме файла с ассемблерным кодом для каждого не ассемблерного входного файла. 
![logo](https://i.ibb.co/283z1qj/2020-03-25-18-46-41.png)

-E: Остановиться после стадии препроцессирования (подготовка к компиляции); не запускать собственно компилятор. 
Вывод делается в форме препроцессированного исходного кода, который посылается на стандартный вывод.

-Wall:   	Вывод сообщений о всех предупреждениях или ошибках, возникающих во время компиляции программы.
![logo](https://i.ibb.co/283z1qj/2020-03-25-18-46-41.png)

-g: Поместить в объектный или исполняемый файл отладочную информацию для отладчика gdb.
Опция должна быть указана и для компиляции, и для компоновки.

nm: получаем названия всех функций, которые определены в .o или .a
![logo](https://i.ibb.co/Wf10z4v/2020-03-25-20-15-20.png)

ld:Команда ld объединяет несколько объектных файлов в один, размещает команды и данные, разрешает внешние ссылки и 
генерирует таблицу имен для символьной отладки. В простейшем случае задаются имена нескольких объектных программ, и 
редактор связей об единяет их в один об ектный модуль, который может затем или выполняться, или использоваться в 
качестве исходного при последующих вызовах ld. Результат редактирования связей помещается в файл с именем a.out, который 
является выполняемым, если во время работы не было зафиксировано ошибок. Если какой-либо исходный файл не является 
объектным, ld предполагает, что это либо текстовый файл с директивами для редактора связей, либо архивная библиотека.

подключение библиотек:
Расширение .a (archive) - для статической библиотеки, .so (shared object) - для разделяемой (динамической). 

Статическая библиотека - это коллекция объектных файлов, которые присоединяются к программе во время линковки программы. 
Таким образом, статические библиотеки используются только при создании программы. Потом в работе самой программы они не 
принимают участие, в отличие от динамических библиотек. 

Динамическая библиотека - это, созданная специальным образом библиотека, которая присоединяется к результирующей 
программе в два этапа. Первый этап, это этап компиляции. На этом этапе линковщик встраивает в программу описания 
требуемых функций и переменных, которые присутствуют в библиотеке. Сами объектные файлы из библиотеки не присоединяются 
к программе. Присоединение этих объектных файлов (кодов функций) осуществляет системный динамический загрузчик во время 
запуска программы. Загрузчик проверяет все библиотеки прилинкованные с программе на наличие требуемых объектных файлов, 
затем загружает их в память и присоединяет их в копии запущенной программы, находящейся в памяти. 

Создадим статическую библиотеку из объектного файла main.o командой
``ar rc libfs.a main.o``
``ranlib libfs.a``

Для компиляции нашего основного файла main.c надо сообщить компилятору, что надо использовать библиотеки. Чтобы 
компилятор знал где искать библиотеки ему надо сообщить каталог, в котором они содержатся и список этих библиотек. 
Каталог с библиотеками указывается ключом -L, в нашем случае библиотека находится в текущем каталоге, значит путь до 
нее будет в виде точки (-L.). Используемые библиотеки перечисляются через ключ -l, после которого указывается название 
библиотеки без префикса lib и окончания .a. В нашем случае этот ключ будет выглядеть, как -lfs. Теперь все одной командой: 

``gcc -c main.c ``

``gcc main.o -L. -lfs -o rezult 
``

Компилятору нужны библиотеки на этапе создания конечного файла, т.е. линковки. В первом случае процесс компиляции 
совершается первой командой, а сборка файла второй командой. 

![logo](https://i.ibb.co/QHT7d6Q/2020-03-25-20-40-49.png)

Создадим динамическую библиотеку:

Скомпилируем main.с:
``gcc -fPIC -c main.c``

Динамическая библиотека - это загружаемая программа, поэтому созданием динамических библиотек занимается сам 
компилятор gcc. Для того, чтобы создать динамическую библиотеку надо использовать ключ -shared: 

``gcc -shared -o libfsdyn.so main.o`` 

В результате получим динамическую библиотеку libfsdyn.so.  

Теперь, чтобы компилировать результирующий файл с использованием динамической библиотеки нам надо собрать файл командой: 

``gcc -с main.с`` 

``gcc main.o -L -lfsdyn -o rezultdyn``

![logo](https://i.ibb.co/cbcYqTz/2020-03-25-20-53-12.png)

5) пример отладки ошибочной программы
сломанная программа, в сообщениях видим в чем ошибка
![logo](https://i.ibb.co/gyXRqxd/2020-03-25-20-55-23.png)

читаем, исправляем
![logo](https://i.ibb.co/pyWQn0X/2020-03-25-21-02-29.png)

6) пример автоматизации:
![logo](https://i.ibb.co/85v2WN6/2020-03-25-21-53-09.png)

Что здесь происходит?

    В 4 строке просто указана минимальная версия CMake необходимая для успешной интерпретации файла.
    В 5 строке определяется переменная PROJECT и ей задается значение hello_world — так будет называться наша программа.
    О чем и говорится в 7 строке. Конструкция ${ИМЯ_ПЕРЕМЕННОЙ} возвращает значение переменной, таким образом проект будет называться hello_world.
    В 9 строке вводятся переменные содержащие список файлов необходимых для сборки проекта.
    И в последней строке идет команда собрать исполняемый файл с именем указанном в переменной PROJECT и из файла в переменной SOURCES.

связывание двух программ:

![logo](https://i.ibb.co/Xx6MyfD/2020-03-25-21-09-54.png)

имеем два подмодуля, которые связаны между собой главным cmake и имеют свои собственные.
add_subdirectory - говорит cmake о подмодуле
add_executable - добавляет исполняемую задачу.