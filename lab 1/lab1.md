лабораторная №1.
флаг ``-с``. Эта опция означает, что необходима только компиляция. 
Из исходных файлов программы создаются объектные файлы в виде name.o
``gcc -c main.c``
Исходные файлы ваших программ компилируются в объектные файлы, а затем компоновщик связывает эти 
объектные файлы вместе, создавая исполняемый файл
![logo](https://i.ibb.co/n3s65MV/2020-03-25-18-35-59.png)

-g: Поместить в объектный или исполняемый файл отладочную информацию для отладчика gdb. 

objdump - отражает информацию из файла

nm: получаем названия всех функций, которые определены в .o или .a
![logo](https://i.ibb.co/Wf10z4v/2020-03-25-20-15-20.png)

подключение библиотек:
Расширение .a (archive) - для статической библиотеки, .so (shared object) - для разделяемой (динамической). 

Создадим статическую библиотеку из объектного файла main.o командой
``ar rc libfs.a main.o``
``ranlib libfs.a``

``gcc -c main.c ``

``gcc main.o -L. -lfs -o rezult 
``

Компилятору нужны библиотеки на этапе создания конечного файла, т.е. линковки. В первом случае процесс компиляции 
совершается первой командой, а сборка файла второй командой. 

![logo](https://i.ibb.co/QHT7d6Q/2020-03-25-20-40-49.png)

Создадим динамическую библиотеку:

Скомпилируем main.с:
``gcc -fPIC -c main.c``

Динамическая библиотека - это загружаемая программа, поэтому созданием динамических библиотек занимается сам 
компилятор gcc. Для того, чтобы создать динамическую библиотеку надо использовать ключ -shared: 

``gcc -shared -o libfsdyn.so main.o`` 

В результате получим динамическую библиотеку libfsdyn.so.  

Теперь, чтобы компилировать результирующий файл с использованием динамической библиотеки нам надо собрать файл командой: 

``gcc -с main.с`` 

``gcc main.o -L -lfsdyn -o rezultdyn``

![logo](https://i.ibb.co/cbcYqTz/2020-03-25-20-53-12.png)

5) пример отладки ошибочной программы
сломанная программа, в сообщениях видим в чем ошибка
![logo](https://i.ibb.co/gyXRqxd/2020-03-25-20-55-23.png)

читаем, исправляем
![logo](https://i.ibb.co/pyWQn0X/2020-03-25-21-02-29.png)

6) пример автоматизации:
![logo](https://i.ibb.co/85v2WN6/2020-03-25-21-53-09.png)

Что здесь происходит?

    В 1 строке просто указана минимальная версия CMake необходимая для успешной интерпретации файла.
    В 5 строке определяется переменная PROJECT и ей задается значение hello_world — так будет называться наша программа.
    О чем и говорится в 7 строке. Конструкция ${ИМЯ_ПЕРЕМЕННОЙ} возвращает значение переменной, таким образом проект будет называться hello_world.
    В 9 строке вводятся переменные содержащие список файлов необходимых для сборки проекта.
    И в последней строке идет команда собрать исполняемый файл с именем указанном в переменной PROJECT и из файла в переменной SOURCES.

связывание двух программ:

![logo](https://i.ibb.co/Xx6MyfD/2020-03-25-21-09-54.png)

имеем два подмодуля, которые связаны между собой главным cmake и имеют свои собственные.
add_subdirectory - говорит cmake о подмодуле
add_executable - добавляет исполняемую задачу.