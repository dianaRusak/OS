Лабораторная работа № 3
Использование виртуальной памяти
0. Ознакомиться со структурой виртуальной памяти и инструментами для работы с ней. 
1. Разработать программу memory-user.c, которая принимает на вход количество 
Mb памяти, которую она резервирует и в которой она размещает массив,  а затем перебирает 
все его элементы в бесконечном цикле или заданное количество времени, которое также вводится
по запросу. 
4. Пока программа memory-user.c выполняется при различных объемах запрошенной памяти 
(включая значительные), из другого терминала выполнить запрос free(). Проанализировать 
результаты распределения памяти до и после завершения memory-user.c с помощью kill.
3. Исследовать распределение памяти для memory-user.c с использованием pmap при различных 
объемах запрошенной памяти (включая значительные).
________________________________________________________________

1. 
Виртуальная память – это адресное пространство процесса. Процесс работает не с 
физической памятью напрямую, а с виртуальной. Такая абстракция позволяет проще писать 
код приложений, не думать о том, что можно случайно обратиться не на те адреса памяти или 
адреса другого процесса. Часть жесткого диска, который используется как виртуальная память, называется свопом.

Язык C поддерживает две функции, которые занимаются решением задач (
    Определить, имеется-ли достаточный объём памяти;
    Получить секцию из доступной памяти;
    Вернуть секцию обратно в пул, чтобы её можно было использовать в других частях программы или другими программами.
)

    malloc: Выделяет заданное число байт и возвращает указатель на них. Если памяти недостаточно, возвращает указатель на NULL (null pointer);
    free: Принимает на вход указатель на область в памяти, выделенной с помощью malloc и возвращает её для дальнейшего использования в программе или операционной системе (на самом деле, некоторые malloc возвращают память для последующего использования только программе, но не ОС).

ОС на базе UNIX имеют в своём арсенале два системных вызова для дополнительной разметки памяти:

    brk:brk() — это очень простой системный вызов. System break — это крайняя граница размеченной для процесса памяти. brk() просто перемещает эту границу вперёд/назад, чтобы увеличить или уменьшить объём выделенной памяти. (прим. переводчика: представьте шкалу масштаба в том же MS Word. System break — это макс. значение, которое может принять бегунок, а сам бегунок — Current break);
    mmap:mmap() (или “memory map”) аналогичен brk(), но является более гибким инструментом. Во-первых, он может разметить память в любом месте адресного пространства, а не только в конце процесса. Во-вторых, он может не просто разметить память (виртуальную) как проекцию к физической или свопу (swap), он может привязать память к конкретным файлам так, что чтение и запись будут оперировать непосредственно с файлом. Антиподом mmap() является munmap().
   
Команда free предоставляет информацию об использованной и неиспользованной памяти, а так же о разделе подкачки (swap). В этой статье разберем несколько полезных примеров использования этой команды.

Синтаксис команды free весьма прост:

free [параметры]

Для запуска будем использовать флаг -t, ведь мы хотим увидеть полную память (включая своп)

Запустим 

    free -t
     
![logo](https://i.ibb.co/gVsjNj9/2020-04-29-23-12-24.png)

Теперь 

    memory-user и снова free - t

![logo](https://i.ibb.co/B40mH61/2020-04-29-23-32-16.png)

Увеличим потенциально занимаемую память до 15гб и повторим эксперимент 

![logo](https://i.ibb.co/ssDpwCK/2020-04-29-23-35-54.png)

Узнаем pid запущенного процесса и выполним команду 

    pmap: Использование памяти процессами. Команда детально раписывает использование операивной памяти процессами в системе. pmap -d PID

![logo](https://i.ibb.co/ZTxhyyQ/2020-04-30-00-13-45.png)

Теперь посмотрим работу kill. После выполнения команды kill проиходит завершение процесса и память освобождается. 

![logo](https://i.ibb.co/DkkdwwB/2020-04-30-00-17-25.png)

![logo](https://i.ibb.co/db93dmj/2020-04-30-00-17-59.png)

![logo](https://i.ibb.co/Zm7WN2V/2020-04-30-00-18-25.png)